<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Bo Yu</title><link href="http://yubo.info/" rel="alternate"></link><link href="http://yubo.info/feeds/all.atom.xml" rel="self"></link><id>http://yubo.info/</id><updated>2013-09-13T00:00:00-07:00</updated><entry><title>Pelican Workflow</title><link href="http://yubo.info/article/pelican-workflow/" rel="alternate"></link><updated>2013-09-13T00:00:00-07:00</updated><author><name>Bo Yu</name></author><id>tag:yubo.info,2013-09-13:article/pelican-workflow/</id><summary type="html">&lt;h3&gt;Preparation&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Crate a virtual environment for Pelican via &lt;code&gt;virtualenv&lt;/code&gt; before installing&amp;nbsp;Pelican&lt;/li&gt;
&lt;li&gt;Once the virtual environment has been created and activated, Pelican can be be installed via &lt;code&gt;pip install pelican&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Install additional dependencies: &lt;code&gt;pip install Markdown typogrify&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Once Pelican has been installed, you can create a source project via the &lt;code&gt;pelican-quickstart&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Prepare two GitHub repositories, one for source project (origin) and one for user pages&amp;nbsp;(userpage)&lt;/li&gt;
&lt;li&gt;Add the source project to the origin&amp;nbsp;repository&lt;/li&gt;
&lt;li&gt;Use ghp-import (installed via &lt;code&gt;pip install ghp-import&lt;/code&gt;) to push the content of the output dir generated by Pelican to the &lt;code&gt;gh-pages&lt;/code&gt; branch&lt;/li&gt;
&lt;li&gt;Push the source project&amp;#8217;s &lt;code&gt;gh-pages&lt;/code&gt; branch to the &lt;code&gt;master&lt;/code&gt; branch of &lt;username&gt;.github.com repository on&amp;nbsp;GitHub.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Writing/Publishing&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Pull the source project from&amp;nbsp;origin&lt;/li&gt;
&lt;li&gt;Activate the virtual environment for&amp;nbsp;Pelican &lt;/li&gt;
&lt;li&gt;Start the local web server and monitor content changes via &lt;code&gt;make devserver&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Add/write content under &lt;code&gt;content&lt;/code&gt; dir&lt;/li&gt;
&lt;li&gt;Once done testing changes, stop the development server via &lt;code&gt;./develop_server.sh stop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Publish the changes to user pages via &lt;code&gt;make github&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Push the changes to source&amp;nbsp;project&lt;/li&gt;
&lt;/ol&gt;</summary><category term="website"></category><category term="pelican"></category><category term="python"></category></entry><entry><title>Random point picking inside an arbitrary polygon</title><link href="http://yubo.info/article/random-point-picking/" rel="alternate"></link><updated>2012-03-24T16:30:00-07:00</updated><author><name>Bo Yu</name></author><id>tag:yubo.info,2012-03-24:article/random-point-picking/</id><summary type="html">&lt;p&gt;I come across the problem of randomly generating geographic locations (as points) inside a certain area (as polygons) for a simulation project. A simple solution is to generate and test random points until one is inside the polygon, which is really unpredictable of the time it takes. The solution here is based on &lt;a href="http://stackoverflow.com/questions/240778/random-points-inside-a-polygon"&gt;a post on Stack Overflow&lt;/a&gt;, aiming to generate a point from a uniform distribution within an arbitrary (convex) polygon. This is achieved in a few&amp;nbsp;steps:&lt;/p&gt;
&lt;h3&gt;Step&amp;nbsp;1&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Polygon_triangulation"&gt;Triangulate the polygon&lt;/a&gt; i.e. find the set of triangles with pairwise non-intersecting interiors whose union is the whole polygon. An easy-to-use open source library (poly2tri) for doing polygon triangulation can be found at &lt;a href="http://code.google.com/p/poly2tri/"&gt;here&lt;/a&gt;. It follows the sweep-line algorithm for constrained Delaunay&amp;nbsp;triangulation.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Polygon triangulation" src="http://www.geom.uiuc.edu/~samuelp/final_delaunay.gif" /&gt;&lt;/p&gt;
&lt;h3&gt;Step&amp;nbsp;2&lt;/h3&gt;
&lt;p _="%" endcodeblock="endcodeblock"&gt;Pick one of the triangles randomly. The probability of a triangle getting picked equals to the area ratio between each triangle and the whole polygon. Each triangle is stored as a two-element tuple: the first element stores the coordinates, and the second is the area ratio as the weight. Then the randomly picking a triangle can be done by calling the following &lt;code&gt;pick_triangle&lt;/code&gt;function.
    {% codeblock Pick triangles randomly lang:python %}
    import random
    def pick_triangle(triangles):
        p = random.uniform(0.0, 1.0)
        for triangle, weight in triangles:
            if p &amp;lt; weight:
                break
            p = p - weight
        return&amp;nbsp;triangle&lt;/p&gt;
&lt;h3&gt;Step&amp;nbsp;3&lt;/h3&gt;
&lt;p&gt;Randomly pick a point inside the chosen triangle, following &lt;a href="http://mathworld.wolfram.com/TrianglePointPicking.html"&gt;the description on Mathworld&lt;/a&gt;. Let &lt;code&gt;v0&lt;/code&gt;, &lt;code&gt;v1&lt;/code&gt;, &lt;code&gt;v2&lt;/code&gt; be vertices of the triangle, represented by their coordinates, so that &lt;code&gt;v0 = (x0,y0)&lt;/code&gt;, etc. Then we generate two random numbers &lt;code&gt;p0&lt;/code&gt; and &lt;code&gt;p1&lt;/code&gt;, both drawn uniformly from the interval &lt;code&gt;[0,1]&lt;/code&gt;. Then we calculate the coordinate of the random point &lt;code&gt;v&lt;/code&gt; by &lt;code&gt;v = v0 + p0*(v1-v0) + p1*(v2-v0)&lt;/code&gt;. &lt;br /&gt; Note that with probability of &lt;code&gt;0.5&lt;/code&gt;, &lt;code&gt;v&lt;/code&gt; lies outside the triangle. Whether &lt;code&gt;v&lt;/code&gt; lies inside or outside the triangle can be easily tested: if &lt;code&gt;p0 + p1 &amp;gt; 1&lt;/code&gt;, then &lt;code&gt;v&lt;/code&gt; is outside the triangle (See the discussion &lt;a href="http://www.blackpawn.com/texts/pointinpoly/default.html"&gt;here&lt;/a&gt;). In that case, we can generate a new point &lt;code&gt;v'&lt;/code&gt; by &lt;code&gt;v' = v0 + (1-p0)*(v1-v0) + (1-p1)*(v2-v0)&lt;/code&gt;, which will be inside the&amp;nbsp;triangle.&lt;/p&gt;</summary><category term="algorithm"></category></entry></feed>